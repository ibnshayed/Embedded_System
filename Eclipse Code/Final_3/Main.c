#include<avr/io.h>
#include<util/delay.h>
#define F_CPU 16000000UL

uint16_t A[] = { 0, 300, 600, 900, 1200, 1500, 1800, 2100, 2400, 6300, 6600,
		6900, 7200, 7500, 7800, 8100, 8400, 8700, 9000, 9300, 9600, 2700, 3000,
		3300, 3600, 3900, 4200, 4500, 4800, 5100, 5400, 5700, 6000, 9900, 10200,
		49035, 48785, 48535, 48285, 48035, 47785, 47535, 47285, 47035, 46785,
		46535, 46285, 46035, 45785, 45535, 45285, 45035, 44785, 44535, 44285,
		13500, 13800, 14100, 14400, 14700, 15000, 15300, 15600, 15900, 16200,
		16500, 16800, 17100, 17400, 17700, 18000, 18300, 18600, 18900, 19200,
		19500, 19800, 20100, 20400, 20700, 21000, 21300, 21600, 65535, 16987,
		17472, 17957, 18442, 18927, 19412, 19897, 20382, 20867, 21352, 21837,
		22322, 22807, 23292, 23777, 24262, 24747, 25232, 25717, 26202, 26687,
		52428, 51804, 51180, 50556, 49932, 49308, 48684, 48060, 12900, 19909,
		19424, 18939, 18454, 17969, 17484, 16999, 16514, 16029, 15544, 52535,
		52285, 52035, 51785, 51535, 51285, 51035, 50785, 50535, 50285, 50035,
		49785, 49535, 49285, 65285, 65035, 64785, 64535, 64285, 64035, 63785,
		63535, 63285, 63035, 62785, 62535, 62285, 62035, 61785, 61535, 61285,
		61035, 60785, 15300, 15000, 14700, 14400, 14100, 13800, 13500, 13200,
		12900, 12600, 60535, 60285, 60035, 59785, 59535, 59285, 59035, 58785,
		58535, 58285, 58035, 57785, 57535, 57285, 57035, 56785, 56535, 56285,
		56035, 55785, 55535, 55285, 55035, 54785, 54535, 54285, 54035, 53785,
		53535, 53285, 53035, 52785, 41820, 43692, 45564, 47436, 49308, 51180,
		53052, 26214, 25729, 25244, 24759, 24274, 23789, 23304, 22819, 22334,
		21849, 21364, 20879, 203 };

uint16_t B[] = { 0, 13107, 13592, 14077, 14562, 15047, 15532, 16017, 16502,
		16987, 17472, 17957, 18442, 18927, 19412, 19897, 20382, 20867, 21352,
		21837, 22322, 22807, 23292, 23777, 24262, 24747, 25232, 25717, 26202,
		26687, 52428, 51804, 51180, 50556, 49932, 49308, 48684, 48060, 12900,
		13200, 13500, 13800, 14100, 14400, 14700, 15000, 15300, 15600, 47436,
		46812, 46188, 45564, 44940, 44316, 43692, 43068, 42444, 41820, 18300,
		18000, 17700, 17400, 17100, 16800, 16500, 16200, 15900, 15600, 12900,
		13200, 13500, 13800, 14100, 14400, 14700, 15000, 15300, 15600, 15900,
		16200, 16500, 16800, 17100, 17400, 17700, 18000, 18300, 18600, 18900,
		19200, 19500, 19800, 20100, 20400, 20700, 21000, 21300, 21600, 65535,
		65285, 65035, 64785, 64535, 64285, 64035, 63785, 63535, 63285, 63035,
		62785, 62535, 62285, 62035, 61785, 61535, 61285, 61035, 60785, 15300,
		15000, 14700, 14400, 14100, 13800, 13500, 13200, 12900, 12600, 41196,
		40572, 39948, 39324, 38700, 38076, 37452, 36828, 36204, 35580, 34956,
		34332, 33708, 33084, 32460, 31836, 31212, 30588, 29964, 29340, 28716,
		28092, 27468, 26844, 28716, 30588, 32460, 34332, 36204, 38076, 39948,
		41820, 43692, 45564, 47436, 49308, 51180, 53052, 26214, 25729, 25244,
		24759, 24274, 23789, 23304, 22819, 22334, 21849, 21364, 20879, 20394,
		19909, 19424, 18939, 18454, 17969, 17484, 16999, 16514, 16029, 15544,
		15059, 14574, 14089, 13604, 13119 };

uint16_t E[] = { 0, 13107, 13592, 14077, 14562, 15047, 15532, 16017, 25244,
		24759, 24274, 23789, 23304, 22819, 22334, 21849, 21364, 20879, 26202,
		26687, 52428, 51804, 51180, 50556, 49932, 49308, 48684, 48060, 47436,
		46812, 46188, 45564, 44940, 44316, 43692, 43068, 42444, 41820, 21352,
		21837, 22322, 22807, 23292, 23777, 24262, 24747, 25232, 25717, 41196,
		10500, 10800, 11100, 11400, 11700, 12000, 12300, 12600, 15900, 16200,
		16500, 16800, 17100, 17400, 17700, 18000, 18300, 18600, 12900, 13200,
		13500, 13800, 14100, 14400, 14700, 15000, 15300, 15600, 18900, 19200,
		19500, 19800, 20100, 20400, 20700, 21000, 21300, 21600, 21300, 21000,
		20700, 20400, 20100, 19800, 19500, 19200, 18900, 18600, 18300, 18000,
		17700, 17400, 17100, 16800, 16500, 16200, 15900, 15600, 12900, 13200,
		40572, 39948, 39324, 38700, 38076, 37452, 36828, 36204, 35580, 28716,
		28092, 27468, 26844, 28716, 30588, 32460, 34332, 36204, 38076, 39948,
		41820, 43692, 45564, 47436, 49308, 51180, 53052, 26214, 25729, 16502,
		16987, 17472, 17957, 18442, 18927, 19412, 19897, 20382, 20867, 20394,
		62785, 62535, 62285, 62035, 61785, 61535, 61285, 61035, 60785, 15300,
		15000, 14700, 14400, 14100, 13800, 13500, 13200, 12900, 12600, 41196,
		40572, 39948, 39324, 38700, 38076, 37452, 36828, 36204, 35580, 34956,
		34332, 33708, 33084, 32460, 31836, 31212, 30588, 29964, 29340, 28716,
		28092, 27468, 26844, 28716, 30588, 32460, 34332, 36204, 38076, 39948,
		41820, 43692, 45564, 47436, 49308, 51180, 53052, 26214, 25729, 25244,
		24759, 24274, 23789, 23304, 22819, 22334, 21849, 21364, 20879, 20394,
		19909, 19424, 18939, 18454, 17969, 17484, 16999, 16514, 16029, 34956,
		34332, 33708, 33084, 32460, 31836, 31212, 30588, 29964, 29340, 15544,
		15059, 14574, 14089, 13604, 13119 };

/**
 * @brief Function to generate wave(a) and wave(b)
 * @details We used lookup tables so microcontroller does not have to do heavy lifting.
 * wave_a_lookup has 219 values and wave_b_lookup has 114 values. The size differ due to wavelength difference.
 * Lookup data points and sizes are calculated accordingly to get smoothest possible waveforms.
 * @details Lookup for wave(a) is generated by "wave_a.c" and for wave(b) is generated by "wave_b.c". Files and can be found in "resources" folder.
 * We used 16-bit data structures to store 16-bit values. 16-bit is the max resolution we can get from TIMER01
 * @details Both OCR1A and OCR1B channels are used to output signals.
 * OCR1A for wave(a) and OCR1B for wave(b).
 */
void generate_waves() {
	uint8_t i = 0, j = 0;
	/*while (1) {
	 OCR1A = wave_a_lookup[i];
	 i++;
	 if (i > 218)
	 i = 0;
	 OCR1B = wave_b_lookup[j];
	 j++;
	 if (j > 113)
	 j = 0;
	 _delay_ms(5);

	 }*/

	while (1) {
		for (int i = 0; i < 512; i++) {
			OCR1A = A[i];
			OCR1B = B[i];
			OCR2A = E[i];
			_delay_ms(2);
		}
	}
}

int main(void) {
	DDRB |= (1 << PB3) | (1 << PB2) | (1 << PB1); //OCR1A and OCR1B as output. We used both

	//Setup variable TOP Fast PWM Mode 14
	// WGM13=1, WGM12=1, WGM11=1, WGM10=0 is for fastPWM in variable TOP mode.
	// Here TOP = ICR1 = 8191 (2^13 - 1)
	// Refer to datasheet pg 136

	OCR1A = 0; // initializing OCR1A
	OCR1B = 0; // initializing OCR1B
	OCR2A = 0;

	TCCR1B |= (1 << WGM13) | (1 << WGM12); //
	TCCR1A |= (1 << COM1A1) | (0 << COM1A0) | (1 << COM1B1) | (0 << COM1B0)
			| (1 << WGM11) | (0 << WGM10);

	//COM1A1:COM1A0=10 COM1B1:COM1B0=10 and for Clear OC1A/OC1B on Compare Match, set OC1A/OC1B at TOP
	// PWM_Frequency= F_osc / (PreScaler*(1+TOP)) = 16MHz / (1*(1023+1))=  1952.88 = 1.95 KHz
	// Resolution= log(TOP+1)/log(2)= 13 bit

	TCCR1B |= (0 << CS12) | (0 << CS11) | (1 << CS10); //CS12->10 = 001 is for 1:1 timer pre-scaler. Start timer

	ICR1 = 65535; // TOP for our fastPWM
	// wave(a) is generated through OCR1A and wave(b) through OCR1B
	generate_waves();
}
